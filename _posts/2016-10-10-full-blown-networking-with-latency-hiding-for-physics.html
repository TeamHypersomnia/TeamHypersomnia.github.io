---
layout: post
title:  Full-blown networking with latency hiding for physics is ready. Also, successful deep cloning of <span class="vstype">b2World</span>!
date:   2016-10-10 21:05:00 +0200
comments_identifier: fullblownnetworking
excerpt_separator: <!--more-->
---

After numeruous experiments and tweaking, I've achieved some really nice, experimental latency hiding for multiplayer physics!<br/>
<br/>
<video id="14.Slowmotion-aimpunch" src="{{ site.img_dir }}15.Multiplayer-networking.webm" controls></video><br/>
<br/>
This was recorded with <span class="vsenum">100ms</span> worth of ping and <span class="vsenum">1% packet loss</span>.<br/>
Sure, the boxes happen to jump back and forth (due to corrections of mispredictions), but it is still perfectly playable.<br/>
The hits from my perspective are also more or less counted. I can assure you that the clients controlling other characters see the bullets hitting their bodies <span class="vsenum">exactly</span>, and not some wall elsewhere.<br/>
Also notice how there is no twitching at all when hugging other players (even though they are completely unpredictable).<br/>
The other characters are automatized clients with randomized movements (sigh sigh my artificial friends).<br/>
<br/>
Okay then, somebody wants to <span class="vsenum">1v1</span> me in my game?<br/>
<br/>
I will write a thorough article about the guts of my netcode in some future if the project receives enough attention.<br/>
Important are the pros and cons of my architectural decisions:<br/>
<br/>
<div style="margin-left:3em">
	<span class="onlinegreen">+</span> <span class="onlinegreen">Making new gameplay features work through the network requires no effort.</span> Praise component-based design, metaprogramming magic and input-based networking.<br/> The exception to that is physics - here, you'd definitely want some dedicated lag concealment techniques. Well, it would still *work*, but reconciliating physical mispredictions without further care looks ugly on the screen.<br/>
	<span class="onlinegreen">+</span> <span class="onlinegreen">Minimal</span> bandwidth, owing again to <span class="vstype">determinism of the simulation</span>. <span class="vsenum">99%</span> of the time, only client inputs are transported.<br/> You could have <span class="vsenum">10000</span> continuously moving crates and bullet shells and you'd still be perfectly able to host a server for a dozen of players on an average home network.<br/>
	<span style="color:red">- Private state</span> (for example inventory of remote characters) is <span style="color:red">hard and ugly</span>. This is because to preserve determinism, the client needs the whole state of the simulation.<br/>It will be easy to peep into somebody's backpack, at least in the early versions. I will some day come up with a nice workaround.<br>
	<span class="onlinegreen">+</span> <span class="onlinegreen">Impossible to cheat otherwise</span>, unless you write hacks that roughly predict the future state of the simulation and direct the shots accordingly. I guess such hack would be very hard to get right, <br/>but if somebody comes up with one, I hope they publish the source code so I can make it into a badass boss.<br/> 
	<span class="onlinegreen">+</span> <span class="onlinegreen">The player with less ping has the advantage</span>, which I believe will come in handy in an MMO setup.<br/> We totally don't want absurd bullets hitting us because a certain somebody with terrible connection is authoritative over his bullet hits.<br/>
	<span style="color:red">- Some bullets however noticeably miss remote players</span>, but it is only the case with bad connections. In particular, that effect is not proportional to the victim's ping, but to yours (the shooter's) only.<br/>
	<span class="onlinegreen">+</span> <span class="onlinegreen">Exact extrapolation</span> when the client inputs stop changing for RTT worth of steps. It means that if your victim keeps the move-forward button pressed for a while (perhaps escaping in panic),<br/> your hit is scored exactly as it happened on your screen. This also means that if two or more friends ride trucks next to each other whilst continuously accelerating,<br/>all see the exact same positions/velocities as server dictates them (again regardless of the network conditions), in particular they are easily able to align the fronts so as to ride in a formation.<br/> No mixing of the timelines occurs.<br/>      
	<span class="onlinegreen">+</span> <span class="onlinegreen">Lagless experience</span> (and I mean completely undistinguishable from local single-player) whenever remote players are far away from your character. Even with <span class="vsenum">3000ms</span> worth of ping.<br> That's right, embrace <span class="font-style:italics">flawless</span> gameplay (including grinding with the deterministic AI) when playing alone at nights on the server (or when the others are somewhere completely else).<br/>
	<br/>
</div>

<!--more-->

For now I will stick to these tradeoffs and will now just go about implementing new gameplay features. 
<br/>
<br/>
<div style="width:100%; height: 15px; border-top: 1px solid rgb(60, 60, 60)"></div>
Obviously, this also concludes my struggles with <span class="vstype">client-side input prediction</span>.<br/>
<br/>
Due to how <span class="vstype">Box2D</span> manages state, that task seemed impossible half-way.<br/>
Imagine that the library does not provide a way to clone the physics world <span class="vsenum">exactly</span>, that is, along with all <span class="vstype">contact information</span>, <span class="vstype">broadphase trees</span> etc.<br/>
Sadly, I needed this functionality, because what client-side prediction does is taking the known, server-time game world (which is a bit in the past),<br/>
<span style="color: white">cloning it</span> and simulating it forward with the yet unacknowledged client commands to produce immediate response to the player's input.<br/>
<br/>
I had no choice but to start hacking inner workings of <span class="vstype">Box2D</span>, <a style="color:white" href="https://github.com/TeamHypersomnia/Hypersomnia/blob/master/game/systems_temporary/physics_system.cpp#L272"><span class="vsparam">[</span>resulting in this monstrosity<span class="vsparam">]</span></a>.<br/>
That *should* clone the <span class="vstype">b2World</span> successfuly; it is the most dangerous piece of code I've written in a while.<br/>
Notice I also had to write copy assignment operators for <span class="vstype">b2BroadPhase</span> and <span class="vstype">b2DynamicTree</span>. Hell of a ride.<br/>
<br/>
Now while in theory I could simply clone all bodies and assign them the same velocities and positions,<br/>
it turns out (not exactly to my surprise) that simulating the clone yields completely different results than simulating the original.<br/> 
Bottom line, glitchy as hell gameplay because of drastic mispredictions even with non-existent jitter and packet drop.<br/>
Contacts mean business.<br/>
<br/>
<div style="width:100%; height: 15px; border-top: 1px solid rgb(60, 60, 60)"></div>
Lastly, take a look at blueprints of experimental stuff we're working on. Straight from the developers' laboratory (excuse the captions in Polish, I guess they add to the enigmatic feel of this) :<br/>
<br/>
<img src="{{ site.img_dir }}blueprint1.png"/><br/>
<br/>
Stay tuned!
